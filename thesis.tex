\documentclass[12pt, notitlepage]{article}
\usepackage[margin=4cm]{geometry}
\usepackage{hyperref}
\usepackage[english]{babel}

\title{Functional Testing of Web Applications}
\author{Stefan Gamerith\\\\
		\emph{Linzerstrasse 429 4215,}\\
		\emph{1140 Wien}\\
		\emph{Student ID: 0925081}}

\begin{document}
	\maketitle
	\thispagestyle{empty}
	\begin{abstract}
		This needs to be done.
	\end{abstract}
	\newpage
	\thispagestyle{empty}
	\tableofcontents
\newpage
\setcounter{page}{1}

\section*{Introduction}
Since the first proposal of HTTP\cite{http-proposal} the Web sites evolved from 
text pages implementing the Request/Response Pattern\cite{request-response}  to  
complex Web applications. Whereas the former draws a clear distinction between a client
who performs a request and a server who sends the response, the latter does not show this 
clear differentiation. Even recently a new communication protocol\cite{web-socket} has been published 
in which the browser acts like a server, thus listening for requests. Tilley and Huang \cite{web-classification} proposed
a new classification scheme for Web applications. They partition Web applications into three different categories:
Class 1 are mainly static Web applications containing static content. Usually these are implemented as plain HTML sites. 
Class 2 are Web applications with some sort of dynamic behavior. Dynamic content is realized witch technologies like Flash\cite{flash},
embedded Java Applet\cite{java-applet}, Javascript or recently CSS3\cite{css3}. 
Class 3 represents the most complex Web applications. In addition to Class 1 and 2 these provide dynamically generated content by server-side technologies
like JSP, PHP, ASP and others. Nowadays most Web applications represent Class 3. Unfortunately developing these requires much more expertise, increasing the
likelihood of defects and often requiring much higher maintenance costs.\\
Probably one of the most challenging aspects are constant changes. P.J.Warren, C.Boldyreff, M.Munro\cite{html-evolution}
presented a study which analyzed six websites. Their study shows a correlation between the complexity and the changes of
a website: The more complex a website get the more likely they will change in the future. 
There are structural and behavioral changes. While the former means changes in the document structure (e.g. Document Object Model\cite{dom} or HTML tree), the latter
includes all changes affecting how Web applications response when an action is performed. 
This requires adaptive testing techniques. Due to the importance of this characteristic a whole section in this thesis outlines the challenges faced
with changing environments.\\ 
Another important aspect is the huge user population. While in the beginnings of the World Wide Web only universities had access,
nowadays the vast majority of the population can view content distributed across all over the world. The typical Web user range from a
mother who does an online shopping tour over a teenager updating the current relationship status in Facebook to a student doing research for
the Bachelor thesis. The integration of designers understanding these different social backgrounds of users is crucial.\\


All of the above characteristics of Web applications make functional testing a difficult task though not impossible.
This thesis first gives an overview of the different testing approaches. For each 
testing method a tool implementing it will be presented.\\
-TODO Brief outline of the contents-
\newpage


\section{Software Testing}
\cite{art-of-software-testing} defines software testing as "the process of executing a program with the intent of finding errors".
According to that one might conclude that finding bugs is the only purpose of software testing. Since TDD\cite{tdd} became popular
another definition coexist: "Software testing is the process of verifying the programs output against predefined values". Besides from 
these IEEE\cite{ieee-testing-definiton} defines software testing as: "The process of operating a system or component under specified conditions, observing or recording the results, and making an evaluation of some aspect of the system or component".\\
\subsection{Testing Techniques}
This section outlines the different software testing techniques\cite{testing-methods} and briefly describes testing methods representing each of
the mentioned techniques in context of Web application testing.
\paragraph{Black-Box Testing} ~\\
This testing technique looks at the code which needs to be tested as a whole. It requires no internal knowledge though test cases are typically 
derived from functional requirements. Therefore some sort of input data is verified against generated outcome.
It is impossible to test all possible input combinations. In \cite{softare-testing-principles} this is named as \textit{Dijkstra's Doctrine}
where for a program accepting a six-character code, ensuring that the first character is numeric and the rest are alphanumeric, an input 
sequence of 9161328320 combinations needs to be generated.
According to \cite{testing-overview} one representative implementing this approach proposed by Di Lucca et al.\cite{decision-table-testing} will be described below.\\
-TODO detail description and explanation of \cite{decision-table-testing}-
\paragraph{White-Box Testing} ~\\
In contrast this technique examines the internals such as code, code structure and control flow. White-Box Testing can be further classified in
static and structural testing. The former does not require executing the code thus the source code is sufficient for examination. The source code
is analyzed either by humans through a code review or by static analysis tools which check for unreachable code, unused variables, memory leaks, use
deprecated libraries and other metrics. The latter executes the program and use the control structure for coverage examination\cite{structural-testing}.\\
-TODO detail description and explanation of \cite{web-whiteBox-testing}-
\paragraph{Grey-Box Testing} ~\\
To clarify the naming conflict, the two terms Grey-Box Testing and Gray-Box Testing are used synonymously in the literature\cite{bridge-grey}. 
In the context of Web applications this new testing technique arises\cite{web-engineering}. Grey-Box Testing is a mixture of Black-Box and White-Box Testing as Grey-Box Testing (Black box + White box = Grey Box).\\
One candidate representing this testing technique is \textit{User-Session based testing}. Though the behavior of Web application is examined like in
Black-Box Testing it requires some internal knowledge (e.g. links to other pages) due to it verifies page or link coverage.\\
-TODO detail description and explanation of \cite{user-session}-
\subsection{Testing Levels}
Testing Levels no different than in traditional software applications. TODO
TODO see \cite{sw-testing-quality-assurance}
\paragraph{Unit Testing} ~\\
IEEE defines Unit Testing as\cite{unit-testing-definition} "testing of individual units or groups of related units". In \cite{sw-testing-quality-assurance}
a unit "is the smallest possible testable software component". Another, yet more practical definition is\cite{practical-unit-testing-definition}:
A unit test is "a test, executed by the developer in a laboratory environment, that should demonstrate that the program meets the requirements set in the design specification". Though these definition clearly clarify what unit testing is in general, often there are misunderstandings. \cite{unit-testing-survey} conclude
before the specification of Unit tests a company should determine the granularity of units and what needs to be tested.
These questions help agreeing on Unit testing principles when developing in a team:\\
\begin{itemize}
	\item \textbf{How is a unit test conducted?}\\
	Nowadays most developers agree on conducting unit tests in the from of test-driven design(TDD)\cite{beck-tdd}. 
	In the earlier days there did not even exist code verifying other code. The only meta language to describe the functionality of a software component was either
	code comments or separated written English text.
	\item \textbf{When are the unit tests executed?}\\
	Unit should should have no external dependencies causing long running Unit tests. In TDD fashion non dependable tests are executed during each iteration,
	usually several times a day. Long running Integration tests typically run as nightly build ideally executed by an automated build environment like
	Maven\cite{maven} or Ant\cite{ant}.
	\item \textbf{Who decides how the unit test shall be conducted?}
	As mentioned above fine grained tests are executed by a developer during one single iteration. It is his/her own responsibility whether a chunk of code needs to
	be tested or not.
\end{itemize}
As we know what a Unit test is one important question arise: How to select Unit test cases? At one extreme test cases with one hundred percent statement coverage
are surely too much. On the other hand no testing at all lead to undesirable behavior at least or even worst unrecoverable damage. 
As a rule of thumb only code causing state changes should be tested. For example testing a method returning only the state of an object or variable (e.g. getter/setter methods) is unnecessary, though they can be used in context with other computations. Unit testing frameworks 
like JUnit\cite{junit} offer a special method dedicated especially for setting up the environment.\\
Writing testable code affects the whole development process. It changes the design of classes fundamentally. One class should serve exactly one and only one purpose. Breaking this principle means high coupling, thus having a dependent class. Dependencies to other classes are not desirable because they introduce new
side effects. In addition third party dependencies may lead to unpredictable or erroneous behavior because of blindly trusting foreign code.
As a best practice third party dependencies should be kept in one single place. This has the advantage of testing third party code in isolation 
and one single point of failure instead of many. However sometimes class level dependencies can not be removed.
One solution T. Mackinnon, S. Freeman and P. Craig proposed\cite{mock-objects} is using mock objects instead of real ones. In the literature the terms \textit{mock object} and \textit{stub implementation} are often used synonymously though M. Fowler clearly differentiate\cite{fowlermocks} (together with similar confusing terms): A \textit{Mock object} is a object having the same interface as the real implementation. It can be initialized with state for further verification. 
A \textit{Stubs} "provide canned answers to calls made during the test." It usually does provide some predefined behavior.\\ 
It can be summarized that Unit testing is an important technique ensuring software quality. Due to the fine granularity of test cases they Unit tests 
should run in isolation. 

\paragraph{Integration Testing} ~\\
As Web applications consists of multiple components there is a need for strategies to combine them. Integration testing is defined as\cite{sw-testing-quality-assurance} "testing the interaction between the modules and interaction with other systems externally". IEEE defines
\textit{integration} as "the process of combining software components, hardware components, or both into an overall system" and \textit{Integration testing} as 
"Testing in which software components, hardware components, or both are combined and tested to evaluate the interaction between them".\\
Integration testing is different depending on the chosen integration strategy. The list below summarizes the main software integration strategies\cite{schattenbest}:\\
\begin{itemize}
	\item \textbf{Big-Bang integration}\\
	IEEE defines it as\cite{big-bang-definition} "A type of integration [testing] in which software elements, hardware elements, or both are combined all at once into an overall system, rather than in stages". These strategy is the simplest and the most obvious though software system are rarely integrated following this approach. It assumes that all integrated software components work well together and all possibilities are taken into account from the beginning. This is of course
unrealistic in today's software applications as dozens of developers work on the same application having more and more dependencies to legacy code. 
	\item \textbf{Continuous integration}\\
	This is probably one of the most popular strategies nowadays. Even small software pieces are integrated continuously. Depending on the 
	size and complexity components are integrated daily (\textit{daily build}), weekly (\textit{weekly build}) or monthly (\textit{monthly build}). 
	Sooner or later as the project progresses one problem arises: What to do if a component can not be integrated because it depends on an unimplemented 
	piece of code? A solution would be to simulate the unimplemented component. This is similar to the concept of \textit{mock objects} mentioned earlier 
	except the object need to provide at least a minimal implementation or even better a fake implementation. If this is not possible another type of integration 
	strategy needs to be chosen locally even though the global continuous integration strategy remains. 
	\item \textbf{Top-down integration}\\
	Software components are integrated from top to bottom. A typical (Web) application consists of three or more layers. Integration starting at the topmost layer
	provides an overview of the whole system even early in the development process. The drawback of this strategy is the simulation of bottom layers with the risk
	of false expectations. Fortunately not all components depend on pieces of code in lower layers. These components are often called
	\textit{sub-system}\cite{sw-testing-quality-assurance}. Sub-systems work isolated from the rest of the components. 
	\item \textbf{Bottom-up integration}\\
	It is basically the opposite of the above. Components residing at the lower layer are integrated before those at higher layers. 
	It doe not require any simulation because all components are defined from ground up. Users interact with an application through the graphical user
	interface residing at the topmost layer which will be implemented late, thus users can interact with the application at the end of the development phase. 
	We recommend developing a demo application (e.g. \textit{prototype}) providing a first impression of the whole system.
	\item \textbf{Bi-directional integration}\cite{sw-testing-quality-assurance}\\
	This approach, also known as \textit{Build integration}\cite{schattenbest}, combines both Top-down and Bottom-up integration. 
	Individual components are grouped into categories. First components in each category are integrated bottom-up leaving the topmost layer.
	Then all remaining components are integrated top-down.
\end{itemize}
\paragraph{System Testing} ~\\
Text...

\section{Test Automation}
Most of the time developers spend time reading other's code. In the remaining time they write code, chat with colleagues or do other things.
Therefore time consuming log running tasks should be done manually by someone else or automated. 
\subsection{Why Test Automation?}
\subsection{Test Automation Frameworks}

\bibliography{literature}
\bibliographystyle{plain}
\end{document}


